<h1> I. </h1>
\textbf{Это интерактивная задача. В формате выходных данных вы найдёте информацию о том, как сбрасывать буфер вывода (делать операцию `flush').}

Медвежонок Лимак загадывает некоторое целое число в интервале $[2, 100]$. Вам необходимо определить, является ли загаданное число простым или составным.

Целое число $x > 1$ называется простым, если у него есть ровно два различных делителя, $1$ и $x$. Если целое число $x > 1$ не является простым, оно называется составным.

Вы можете сделать до $20$ запросов о делителях загаданного числа. Каждый запрос~--- это одно целое число в интервале $[2, 100]$. Проверяющая программа выведет <<\t{yes}>>, если целое число из запроса является делителем загаданного числа, и <<\t{no}>> в противном случае.

Например, если загадано число $14$, то проверяющая программа выведет <<\t{yes}>> только для запросов $2$, $7$ или $14$.

Когда вы закончите задавать вопросы, выведите <<\t{prime}>> (если считаете, что загаданное число простое) или <<\t{composite}>> (если считаете, что загаданное число составное), сделайте операцию `flush' и завершите работу программы.

Вы получите вердикт \t{Wrong Answer}, если сделаете больше $20$ запросов о делителях или если ваша программа выведет число не из интервала $[2, 100]$. Разумеется, вы получите вердикт \t{Wrong Answer}, если неправильно определите тип загаданного числа.

Вы получите вердикт \t{Idleness Limit Exceeded}, если не будете ничего выводить (а тестирующая программа будет ожидать ввода) или забудете сделать операцию `flush' после какого-нибудь вывода (смотри ниже).

\InputFile
После каждого запроса требуется считать одну строку из входных данных (стандартный ввод). Эта строка будет <<\t{yes}>> (без кавычек), если выведенное число является делителем загаданного, и <<\t{no}>> (без кавычек) в противном случае.

\OutputFile
Не более $20$ раз вы можете сделать запрос~--- вывести целое число в диапазоне $[2, 100]$ в одной строке. Обязательно требуется вывести перевод строки и сделать операцию `flush'. После сброса буфера необходимо считать ответ на запрос из входных данных.

В любой момент можно перестать делать запросы и вывести <<\t{prime}>> (без кавычек) или <<\t{composite}>> (без кавычек). После этого требуется сделать `flush' и завершить программу.

Для сброса буфера вывода (то есть для операции `flush') сразу после вывода числа или ответа и перевода строки можно сделать:
\begin{itemize}
\item \t{fflush(stdout)} в языке C++;
\item \t{System.out.flush()} в Java;
\item \t{stdout.flush()} в Python;
\item \t{flush(output)} в Pascal;
\item смотрите документацию для других языков.
\end{itemize}

\textbf{Взломы.} Чтобы совершить взлом, вам требуется указать загаданное число~--- одно целое число в интервале $[2, 100]$. Разумеется, у взламываемого решения не будет возможности прочитать это число из входных данных.

\Examples

\Note
Ниже приведён пример протокола общения для первого и второго примеров.

В первом примере Лимак загадал число $30$.

$\begin{tabular}{  c | c }
solution & system \\
\hline
  2 &  \\
   & yes \\
\hline
  80 &  \\
   & no \\
\hline
  5 &  \\
   & yes \\
\hline
composite & \\
\hline
\end{tabular}$

Загаданное число делится на $2$ и $5$, следовательно, является составным. Обратите внимание, что не требуется точно угадывать загаданное число.

Во втором примере Лимак загадал число $59$.

$\begin{tabular}{  c | c }
solution & system \\
\hline
  58 &  \\
   & no \\
\hline
  59 &  \\
   & yes \\
\hline
  78 &  \\
   & no \\
\hline
  78 &  \\
   & no \\
\hline
  2 &  \\
   & no \\
\hline
prime & \\
\hline
\end{tabular}$

Число $59$ является делителем загаданного числа, но в интервале $[2, 100]$ есть только одно число с таким делителем, и оно является простым. Обратите внимание, что ответ известен уже после второго запроса, но не запрещается продолжать спрашивать (если при этом не превышается лимит на $20$ запросов).


[Оригинал задачи](https://codeforces.com/contest/679/problem/A)

[Решение задачи](Solution_I.md)